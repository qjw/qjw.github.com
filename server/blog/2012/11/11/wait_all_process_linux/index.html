<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<script type="text/javascript" src="/js/jquery-1.7.1.min.js"></script>
	<script type="text/javascript">
    var switch_flag_=0
    $(document).ready(function(){
            $("#float_top_right").css({ top: "10px",right: "10px", width: "200", position: "fixed", background: "#99ff00" })
                .css({"border-style": "solid"});
            $("#float_top_right").prepend("<div id=float_top_right_header>点击切换位置</div>");
            $("#float_top_right_header").css({ width: "100%"}).css({ height: "20"})
                .css({ background: "#9900ff" }).css("cursor","pointer")
            
            // OnClick做实际的事情
            $("#float_top_right_header").click(function(event){
                event.preventDefault();
                if(switch_flag_){
                    $("#float_top_right").css({ bottom: ""});
                    $("#float_top_right").css({ top: "10px"});
                }else{
                    $("#float_top_right").css({ top: ""});
                    $("#float_top_right").css({ bottom: "10px"});
                }
                switch_flag_= !switch_flag_;
            });
	})
	</script>
    <title>Linux下等待所有进程结束</title>
</head>
<body>
    <table align="left" border="0" cellpadding="0" cellspacing="0" style="width: 100%; ">
        <tbody>
            <tr>
                <td>
                    <link href="/js/google-code-prettify/prettify.css" type="text/css" rel="stylesheet"/>
<script type="text/javascript" src="/js/google-code-prettify/prettify.js"></script>
<script type="text/javascript">
$(document).ready(function(){
    $('pre').addClass('prettyprint linenums:0') //添加Google code Hight需要的class
	
	// 导入Prettify的javascript
    prettyPrint()
})
</script>
<strong>导航：[<a href="/">首页</a>]->[<a href="/categories/linux/">linux</a>]->[<a href="/blog/2012/11/11/wait_all_process_linux">Linux下等待所有进程结束</a>]</strong>

<p>为了避免在信号中做过多的逻辑，以及互斥，可以考虑建一个unix sock，然后将进程退出的必需信息作为报文发送出去。在主线程中用select等待即可。用pipe若同时写可能会有乱序问题。</p>

<pre><code>    #include &lt;unistd.h&gt;
    #include &lt;cstdio&gt;
    #include &lt;sys/types.h&gt;
    #include &lt;sys/wait.h&gt;


    void selfpipe_sigh(int n)
    {
        printf("child exit\n");
        int st;
        int pid;
        while((pid = waitpid(-1, &amp;st, WNOHANG)) &gt; 0)
        {
            if(WIFEXITED(st))
                printf("child %d exit normal,status %d\n",pid,WEXITSTATUS(st));
            else if(WIFSIGNALED(st))
                printf("child %d exit by singal,sig %d\n",pid,WTERMSIG(st));
        }
    }

    int main(int argc,char** argv)
    {
        struct sigaction act;
        act.sa_handler = selfpipe_sigh;
        sigaction(SIGCHLD, &amp;act, NULL);
        act.sa_handler = SIG_IGN;
        sigaction(SIGPIPE, &amp;act, NULL);

        int pid_t = fork();
        if(pid_t &lt; 0)
            return 1;
        if(0 == pid_t)
        {
            char* new_argv[]={
                argv[1],
                NULL
            };
            if(execvp(argv[1],new_argv) &lt; 0)
                return 1;
            return 0;
        }
        else
        {
            printf("pid %d\n",pid_t);
        }
        while(true)
        {
            printf("i am running\n");
            sleep(1);
        }
        return 0;
    }
</code></pre>

<h1>waitpid和SIGCHID关联讨论</h1>

<p>见<a href="http://bbs.chinaunix.net/thread-828942-2-1.html">http://bbs.chinaunix.net/thread-828942-2-1.html</a></p>

<p>根本就不需要找回来！
好比有五个进程，
不妨分别称为 p1 p2 p3 p4 p5，
一开始 p1 结束了，发了一个 SIGCHLD(s1)，
这时父进程可能空闲了，于是开始处理这个信号，假设处理的过程中 p2 又结束了，又发了一个 SIGCHLD(s2)，
这时候已经有两个信号了（一个正在处理，一个待处理），这时如果 p3 又结束了，那么它发的那个 SIGCHLD(s3) 势必会丢失，
丢失了怎么办？
没关系，因为那个信号处理函数是个循环嘛，
所以 while(waitpid()) 的时候，会把 p1 p2 p3 都处理的。
即使是很不幸，因为十分凑巧的原因，p3 没有被回收，导致变成僵尸进程了，也没关系，
因为还有 p4 p5 嘛，等到 p4 或者 p5 结束的时候，
又会再一次调用 while(waitpid())，到时候虽说这个 while(waitpid()) 是由 p4/p5 引起的，但是它也会一并把 p3 也处理的，因为它是个循环嘛！</p>

<p>如果还搞不懂，你就再看看 waitpid 的 man。</p>

<p>记住一点：
waitpid 和 SIGCHLD 没关系，即使是某个子进程对应的 SIGCHLD 丢失了，只要父进程在任何一个时刻调用了 waitpid，那么这个进程还是可以被回收的。</p>

<p>哎呀呀，简直费劲死了，其实说白了，就是一个“生产者－消费者”问题。
子进程结束的时候，系统“生产”出一个僵尸进程，
同时用 SIGCHLD 通知父进程来“消费”这个僵尸进程，
即使是 SIGCHLD 丢失了，没有来得及消费，
但是只要有一次消费，就会把所有的僵尸进程都处理光光！
（我再说一遍：因为，while(waitpid()) 是个循环嘛！）</p>

<h1>忽略SIGCHLD信号避免僵尸进程</h1>

<p>见<a href="http://pubs.opengroup.org/onlinepubs/7908799/xsh/sigaction.html">http://pubs.opengroup.org/onlinepubs/7908799/xsh/sigaction.html</a></p>

<p>If a process sets the action for the SIGCHLD signal to SIG_IGN, the behaviour is unspecified, except as specified below. If the action for the SIGCHLD signal is set to SIG_IGN, child processes of the calling processes will not be transformed into zombie processes when they terminate. If the calling process subsequently waits for its children, and the process has no unwaited for children that were transformed into zombie processes, it will block until all of its children terminate, and wait(), wait3(), waitid() and waitpid() will fail and set errno to [ECHILD]. If the Realtime Signals Extension option is supported, any queued values pending will be discarded and the resources used to queue them will be released and made available to queue other signals.</p>

<h1>参考</h1>

<ol>
<li><a href="http://stackoverflow.com/questions/282176/waitpid-equivalent-with-timeout">http://stackoverflow.com/questions/282176/waitpid-equivalent-with-timeout</a></li>
<li><a href="http://bbs.chinaunix.net/thread-828942-2-1.html">http://bbs.chinaunix.net/thread-828942-2-1.html</a></li>
<li><a href="http://pubs.opengroup.org/onlinepubs/7908799/xsh/sigaction.html">http://pubs.opengroup.org/onlinepubs/7908799/xsh/sigaction.html</a></li>
</ol>



<br>
<br>

<script>
(function() {
  var cx = '000743863249122818147:j_aeulgywie';
  var gcse = document.createElement('script'); gcse.type = 'text/javascript';
  gcse.async = true;
  gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
      '//www.google.com/cse/cse.js?cx=' + cx;
  var s = document.getElementsByTagName('script')[0];
  s.parentNode.insertBefore(gcse, s);
})();
</script>
<gcse:search></gcse:search>

<hr>
<br>
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'qjw'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

<div id=float_top_right>
<h4>&nbsp;分类浏览[linux]</h4>
<ul>
    
    <li>
    <a href="/categories/other/" title="查看此类别的所有文章">
        other(20)</a>
    </li>
    
    <li>
    <a href="/categories/www/" title="查看此类别的所有文章">
        www(10)</a>
    </li>
    
    <li>
    <a href="/categories/bash/" title="查看此类别的所有文章">
        bash(42)</a>
    </li>
    
    <li>
    <a href="/categories/wtl/" title="查看此类别的所有文章">
        wtl(14)</a>
    </li>
    
    <li>
    <a href="/categories/cpp/" title="查看此类别的所有文章">
        cpp(43)</a>
    </li>
    
    <li>
    <a href="/categories/network/" title="查看此类别的所有文章">
        network(15)</a>
    </li>
    
    <li>
    <a href="/categories/windows/" title="查看此类别的所有文章">
        windows(15)</a>
    </li>
    
    <li>
    <a href="/categories/lua/" title="查看此类别的所有文章">
        lua(4)</a>
    </li>
    
    <li>
    <a href="/categories/js/" title="查看此类别的所有文章">
        js(6)</a>
    </li>
    
    <li>
    <a href="/categories/wingui/" title="查看此类别的所有文章">
        wingui(18)</a>
    </li>
    
    <li>
    <a href="/categories/linux/" title="查看此类别的所有文章">
        linux(17)</a>
    </li>
    
    <li>
    <a href="/categories/game/" title="查看此类别的所有文章">
        game(3)</a>
    </li>
    
</ul>
</div>


                </td>
                <td style="width: 210px; ">
                    &nbsp;
                </td>
            </tr>
        </tbody>
    </table>
</body>
</html>
